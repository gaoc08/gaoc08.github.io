---
layout:     post
title:      iOS 中 Atomic 属性“线程不安全”的真相
subtitle:   
date:       2018-07-12
author:     G
header-img: img/post-bg-debug.png
catalog: true
tags:
    - iOS
    - 线程安全
    - atomic
---

# 背景

当我们提到 atomic 的时候，第一反应就是和 nonatomic 对应。nonatomic 是非原子性的，线程不安全的。那么 atomic 就是原子性的，线程安全的。

BUT，网上又有一大推的文章再说 atomic 也不是线程安全的，那么到底是怎么回事呢？

# Atomic 的工作原理

Atomic 实际上相当于一个引用计数器，这个大家很熟悉，如果被标记了atomic，那么被标记了的内存本身就有了一个引用计数器，第一个占用这块内存的线程，会给这个计数器+1，在这个线程操作这块内存期间，其他线程在访问这个内存的时候，如果发现“引用计数器”不为0，则阻塞，实际上阻塞并不等于休眠，它是基于cpu轮询片，休眠除非被叫醒，否则无法继续执行，阻塞则不同，每个cpu 轮询片到这个线程的时候都会尝试继续往下执行，可见 阻塞相对于休眠来讲，阻塞是主动的，休眠是被动的，如果引用计数器为0，轮询片到来，则先给这块内存的引用计数器+1，然后再去操作，atomic 实现操作序列化的具体过程大概就是如此。

# Atomic 的线程安全和“不安全”

1. atomic 的读写是线程安全的。
	
	> atomic 起作用的是属性的 setter 和 getter 方法。
	
	- 对于基本数据类型
		
		```
		例如 @property (atomic) double d;
		那么它一定是线程安全的。
		```
	
	- 对于 OC 对象
	
		```
		例如 @property (atomic) NSMutaleArray *array;
		它其实包含了两部分的线程安全问题：
		1. 数组的指针。
		2. 数组的内容。
		
		对于 atomic 来说，它修饰的是数组的指针，跟数组的内容没有半毛钱关系。
		对于被 atomic 修饰的数组的指针来说，它绝对以及必须一定是线程安全的。
		所以其实这个时候 atomic 已经完美的完成了它自身的使命。
		```
	
2. atomic 的 “线程不安全”

	那么网上很多文章写的“Atomic 线程不安全”又是怎么一回事儿呢？这部分有两方面理解。

	1.  atomic 只对 setter 和 getter 方法加锁，所以只保证了读写的安全。不能保证其他操作安全，比如 release 等操作。

	2. 是指修饰的容器内部修改不安全（这里有点偷换概念）
	
	   我们接着上面的例子 @property (atomic) NSMutaleArray *array; 我们刚刚已经说了，线程安全包含了两部分的：1. 数组的指针 2.数组的内容。而“线程不安全”则说的是 **数组的内容**。可是 atomic 它只是修饰数组指针的啊，数组内容的线程不安全还要赖到它的头上，有点过分了哈。

# 结语

	说到了这里，我们应该已经明白了 atomic 的线程安全和 “不安全” 都是怎么回事了。
	不过我们还是需要搞清楚具体的原理，这样就不会“冤枉人”了。
	至于数组的内容修改要如何保证线程安全，那就是另外一个话题了，有兴趣的可以在书中、网上找找。